
.. _program_listing_file__home_chunwei_project_cinn2_cinn_runtime_buffer.h:

Program Listing for File buffer.h
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_runtime_buffer.h>` (``/home/chunwei/project/cinn2/cinn/runtime/buffer.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <glog/logging.h>
   
   #include <string>
   namespace cinn {
   namespace runtime {
   
   struct Shape {
     using value_type = int32_t;
   
     Shape() = default;
   
     Shape(const Shape& other);
   
     bool defined() const { return data_; }
   
     uint32_t ndims() const { return ndims_; }
   
     value_type* data() { return data_; }
     const value_type* data() const { return data_; }
   
     void Resize(int ndim);
   
     uint32_t num_elements() const;
   
     value_type& operator[](int i);
     value_type operator[](int i) const;
   
    private:
     uint32_t ndims_{0};
     int32_t* data_{};
   };
   
   template <typename T>
   class Buffer {
    public:
     Buffer(const Shape& shape) : shape_(shape) {}
   
     void AllocHost() {
       CHECK(shape_.defined());
       data_ = new T[shape_.num_elements()];
       CHECK(data_) << "alloc buffer failed";
     }
     void DeallocHost() {
       if (data_) delete data_;
       data_ = nullptr;
     }
   
     T& operator()(int i0) {
       CHECK_EQ(shape_.ndims(), 1);
       return static_cast<T*>(data_)[i0];
     }
     T& operator()(int i0, int i1) {
       CHECK_EQ(shape_.ndims(), 2);
       return static_cast<T*>(data_)[i0 * shape_[0] + i1];
     }
     T& operator()(int i0, int i1, int i2) {
       CHECK_EQ(shape_.ndims(), 3);
       return static_cast<T*>(data_)[i0 * shape_[1] * shape_[2] + i1 * shape_[2] + i2];
     }
   
    private:
     Shape shape_;
     void* data_{};
   };
   
   }  // namespace runtime
   }  // namespace cinn
