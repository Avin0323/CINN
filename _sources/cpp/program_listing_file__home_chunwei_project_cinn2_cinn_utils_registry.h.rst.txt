
.. _program_listing_file__home_chunwei_project_cinn2_cinn_utils_registry.h:

Program Listing for File registry.h
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_utils_registry.h>` (``/home/chunwei/project/cinn2/cinn/utils/registry.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   #include <glog/raw_logging.h>
   
   #include <map>
   #include <string>
   #include <vector>
   
   template <typename EntryType>
   class Registry {
    public:
     inline const std::vector<const EntryType *> &List() { return const_list_; }
   
     inline std::vector<std::string> ListAllNames() {
       std::vector<std::string> names;
       for (auto p = fmap_.begin(); p != fmap_.end(); ++p) {
         names.push_back(p->first);
       }
       return names;
     }
     inline const EntryType *Find(const std::string &name) {
       typename std::map<std::string, EntryType *>::const_iterator p = fmap_.find(name);
       if (p != fmap_.end()) {
         return p->second;
       } else {
         return nullptr;
       }
     }
     /*   inline void AddAlias(const std::string &key_name, const std::string &alias) {
         EntryType *e = fmap_.at(key_name);
         if (fmap_.count(alias)) {
           CHECK_EQ(e, fmap_.at(alias)) << "Trying to register alias " << alias << " for key " << key_name << " but "
                                        << alias << " is already taken";
         } else {
           fmap_[alias] = e;
         }
       } */
     inline EntryType &__REGISTER__(const std::string &name) {
       std::lock_guard<std::mutex> guard(registering_mutex);
       if (fmap_.count(name)) {
         return *fmap_[name];
       }
   
       EntryType *e = new EntryType();
       e->name      = name;
       fmap_[name]  = e;
       const_list_.push_back(e);
       entry_list_.push_back(e);
       return *e;
     }
   
     inline EntryType &__REGISTER_OR_GET__(const std::string &name) {
       RAW_LOG(INFO, "Register %s", name.c_str());
       if (!fmap_.count(name)) {
         return __REGISTER__(name);
       } else {
         return *fmap_.at(name);
       }
     }
   
     static Registry *Global() {
       static Registry<EntryType> inst;
       return &inst;
     }
   
     Registry() = default;
     ~Registry() {
       for (size_t i = 0; i < entry_list_.size(); ++i) {
         delete entry_list_[i];
       }
     }
   
    private:
     std::vector<EntryType *> entry_list_;
     std::vector<const EntryType *> const_list_;
     std::map<std::string, EntryType *> fmap_;
     std::mutex registering_mutex;
   };
   
   template <typename EntryType, typename FunctionType>
   class FunctionRegEntryBase {
    public:
     std::string name;
     std::string description;
     // std::vector<ParamFieldInfo> arguments;
     FunctionType body;
     std::string return_type;
   
     inline EntryType &set_body(FunctionType body) {
       this->body = body;
       return this->self();
     }
     inline EntryType &describe(const std::string &description) {
       this->description = description;
       return this->self();
     }
     inline EntryType &set_return_type(const std::string &type) {
       return_type = type;
       return this->self();
     }
   
    protected:
     inline EntryType &self() { return *(static_cast<EntryType *>(this)); }
   };
   
   #define CINN_REGISTRY_REGISTER(EntryType, EntryTypeName, Name) \
     static EntryType &__make_##EntryTypeName##_##Name##__ = ::Registry<EntryType>::Global()->__REGISTER__(#Name)
   
   #define CINN_STR_CONCAT_(__x, __y) __x##__y
   #define CINN_STR_CONCAT(__x, __y) CINN_STR_CONCAT_(__x, __y)
