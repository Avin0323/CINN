
.. _program_listing_file__home_chunwei_project_cinn2_cinn_common_graph_utils.h:

Program Listing for File graph_utils.h
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_common_graph_utils.h>` (``/home/chunwei/project/cinn2/cinn/common/graph_utils.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <glog/logging.h>
   
   #include <algorithm>
   #include <functional>
   #include <list>
   #include <map>
   #include <memory>
   #include <set>
   #include <string>
   #include <tuple>
   #include <unordered_map>
   #include <vector>
   
   #include "cinn/common/object.h"
   #include "cinn/common/shared.h"
   
   namespace cinn {
   namespace common {
   
   #ifdef As
   #undef As
   #endif
   
   class GraphNode;
   
   class GraphEdge : public Object {
    public:
     GraphEdge(GraphNode* source, GraphNode* sink, int index = -1) : source_(source), sink_(sink), index_(index) {}
   
     GraphNode* source() const { return source_; }
     GraphNode* sink() const { return sink_; }
     const char* type_info() const override { return __type_info__; }
     int index() const { return index_; }
   
    private:
     int index_{-1};
     GraphNode* source_{};
     GraphNode* sink_{};
     static constexpr char* __type_info__ = "graph_edge";
   };
   
   struct GraphEdgeCompare {
     bool operator()(const common::Shared<GraphEdge>& a, const common::Shared<GraphEdge>& b) const;
   };
   
   class GraphNode : public Object {
    public:
     virtual std::string id() const = 0;
   
     template <typename EdgeT = GraphEdge>
     std::tuple<EdgeT*, EdgeT*> LinkTo(GraphNode* other) {
       EdgeT *a, *b;
       CHECK(other);
       CHECK_NE(other, this) << "cannot link to itself";
       auto edge  = make_shared<GraphEdge>(this, other, index_outlinks);
       auto edge1 = make_shared<GraphEdge>(this, other, other->index_inlinks);
       index_outlinks++;
       other->index_inlinks++;
       outlinks_.insert(edge);
       other->inlinks_.insert(edge1);
   
       for (auto& item : outlinks_) {
         if (item->sink()->id() == other->id()) {
           a = static_cast<EdgeT*>(item.get());
           break;
         }
       }
       for (auto& item : other->inlinks_) {
         if (item->sink()->id() == other->id()) {
           b = static_cast<EdgeT*>(item.get());
           break;
         }
       }
       return std::make_tuple(a, b);
     }
   
     void UnLinkTo(GraphNode* other) {
       if (other == this) return;
       // remove outlink
       {
         auto it = std::find_if(outlinks_.begin(), outlinks_.end(), [&](const Shared<GraphEdge>& x) {
           return x->sink() == other || x->source() == other;
         });
         if (it != outlinks_.end()) {
           outlinks_.erase(it);
           other->UnLinkTo(this);
         }
       }
       {
         auto it = std::find_if(inlinks_.begin(), inlinks_.end(), [&](const Shared<GraphEdge>& x) {
           return x->sink() == other || x->source() == other;
         });
         if (it != inlinks_.end()) {
           inlinks_.erase(it);
           other->UnLinkTo(this);
         }
       }
     }
   
     bool IsLinkedTo(GraphNode* other) const {
       for (auto& e : outlinks_) {
         if (e->sink()->id() == other->id()) return true;
       }
       return false;
     }
   
     virtual const std::set<Shared<GraphEdge>, GraphEdgeCompare>& inlinks() const { return inlinks_; }
     virtual const std::set<Shared<GraphEdge>, GraphEdgeCompare>& outlinks() const { return outlinks_; }
   
     void ResetVisitMeta() { visited_time_ = 0; }
     void VisitOnce() const { visited_time_++; }
     bool visited() const { return inlinks_.empty() || visited_time_ == inlinks_.size(); }
   
     const char* type_info() const override { return __type_info__; }
   
     GraphNode() = default;
   
     static const char* __type_info__;
   
    protected:
     std::set<common::Shared<GraphEdge>, GraphEdgeCompare> inlinks_;
     std::set<common::Shared<GraphEdge>, GraphEdgeCompare> outlinks_;
   
     mutable int visited_time_{};
     int index_inlinks{0};
     int index_outlinks{0};
   };
   
   class Graph {
    public:
     using node_order_t = std::vector<GraphNode*>;
     using edge_order_t = std::vector<GraphEdge*>;
   
     GraphNode* RegisterNode(size_t key, GraphNode* node);
     GraphNode* RegisterNode(const std::string& key, GraphNode* node);
   
     GraphNode* RetriveNode(size_t key) const;
     GraphNode* RetriveNode(const std::string& key) const;
   
     std::vector<const GraphNode*> start_points() const;
     std::vector<GraphNode*> start_points();
   
     std::tuple<std::vector<GraphNode*>, std::vector<GraphEdge*>> topological_order() const;
   
     std::vector<GraphNode*> dfs_order();
   
     std::set<GraphNode*> dependencies(const std::vector<GraphNode*>& nodes);
   
     std::vector<const GraphNode*> nodes() const;
     std::vector<GraphNode*> nodes();
   
     std::set<GraphNode*> CollectNodes(std::function<bool(const common::GraphNode*)>&& teller);
   
     void DropNode(GraphNode* n) {
       auto it = std::find_if(nodes_.begin(), nodes_.end(), [&](auto& x) { return x.get() == n; });
       if (it != nodes_.end()) {
         nodes_.erase(it);
       }
     }
   
     std::string Visualize() const;
   
     size_t num_nodes() const { return nodes_.size(); }
   
    protected:
     std::map<size_t, GraphNode*> registry_;
     std::vector<Shared<GraphNode>> nodes_;
   };
   
   }  // namespace common
   }  // namespace cinn
   
   namespace std {
   template <>
   struct hash<cinn::common::GraphNode> {
     size_t operator()(const cinn::common::GraphNode& x) { return reinterpret_cast<size_t>(hash<std::string>()(x.id())); }
   };
   
   }  // namespace std
