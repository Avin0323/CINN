
.. _program_listing_file__home_chunwei_project_cinn2_cinn_backends_codegen_c_x86.h:

Program Listing for File codegen_c_x86.h
========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_backends_codegen_c_x86.h>` (``/home/chunwei/project/cinn2/cinn/backends/codegen_c_x86.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <string>
   
   #include "cinn/backends/codegen_c.h"
   
   namespace cinn {
   namespace backends {
   
   class CodeGenCX86 : public CodeGenC {
    public:
     enum class Feature : int {
       None   = 0,
       SSE    = 1,       
       AVX256 = 1 << 1,  // ! support AVX256 instruction set.
       AVX512 = 1 << 2,  // ! support AVX512 instruction set.
       BLAS   = 1 << 3,  // ! support BLAS library.
     };
   
     Feature feature{Feature::None};
   
     CodeGenCX86(Target target, Feature feature) : CodeGenC(target), feature(feature) {}
   
    protected:
     void Visit(const ir::Add *op) override;
     void Visit(const ir::Sub *op) override;
     void Visit(const ir::Mul *op) override;
     void Visit(const ir::Div *op) override;
     void Visit(const ir::Mod *op) override { CodeGenC::Visit(op); }
     void Visit(const ir::EQ *op) override { CodeGenC::Visit(op); }
     void Visit(const ir::NE *op) override { CodeGenC::Visit(op); }
     void Visit(const ir::LT *op) override { CodeGenC::Visit(op); }
     void Visit(const ir::LE *op) override { CodeGenC::Visit(op); }
     void Visit(const ir::GT *op) override { CodeGenC::Visit(op); }
     void Visit(const ir::GE *op) override { CodeGenC::Visit(op); }
     void Visit(const ir::And *op) override { CodeGenC::Visit(op); }
     void Visit(const ir::Or *op) override { CodeGenC::Visit(op); }
   
     void Visit(const ir::Load *op) override;
     void Visit(const ir::Store *op) override;
     void Visit(const ir::Broadcast *op) override;
   
     // @{
     bool SupportsSSE() { return static_cast<int>(feature) & static_cast<int>(Feature::SSE); }
     bool SupportsAVX256() { return static_cast<int>(feature) & static_cast<int>(Feature::AVX256); }
     bool SupportsAVX512() { return static_cast<int>(feature) & static_cast<int>(Feature::AVX512); }
     bool SupportsBLAS() { return static_cast<int>(feature) & static_cast<int>(Feature::BLAS); }
     // @}
   
     // 3. -> set1(3.)
     // a[i:j] -> load_ps(a+i)
     void PrintVecInputArgument(const Expr *op);
     void PrintVecOutputArgument(const Expr *op);
   
     template <typename Op>
     void PrintAbsAddr(const Op *op) {
       os() << op->tensor.template As<ir::_Tensor_>()->name << " + ";
   
       auto index   = op->index();
       auto *ramp_n = index.template As<ir::Ramp>();
       if (ramp_n) {
         CHECK(!ramp_n->base.template As<ir::Ramp>()) << "base of a Ramp node should not be Ramp type";
         Print(ramp_n->base);
       } else {
         Print(op->index());
       }
     }
   
     template <typename Op>
     void VisitBinaryOp(const Op *op, Expr a, Expr b, const std::string &op_repr);
   };
   
   template <typename Op>
   void CodeGenCX86::VisitBinaryOp(const Op *op, Expr a, Expr b, const std::string &op_repr) {
     CHECK_EQ(a.type(), b.type());
   
     // scalar.
     if (a.type().lanes() == 1) {
       CodeGenC::Visit(op);
       return;
     }
   
     // TODO(Superjomn) Consider support BLAS.
     int bits = a.type().bits() * a.type().lanes();
     if (SupportsAVX512()) {
       CHECK_EQ(bits, 512) << "the bits of computation should be times of 512";
       os() << "cinn_avx512_" << op_repr << "(";
       PrintVecInputArgument(&a);
       os() << ", ";
       PrintVecInputArgument(&b);
       os() << ")";
     } else if (SupportsAVX256()) {
       CHECK_EQ(bits, 256) << "the bits of computation should be times of 256";
       os() << "cinn_avx256_" << op_repr << "(";
       PrintVecInputArgument(&a);
       os() << ", ";
       PrintVecInputArgument(&b);
       os() << ")";
     } else {
       CINN_NOT_IMPLEMENTED
     }
   }
   
   }  // namespace backends
   }  // namespace cinn
