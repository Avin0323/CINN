
.. _program_listing_file__home_chunwei_project_cinn2_cinn_ir_operation.h:

Program Listing for File operation.h
====================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_ir_operation.h>` (``/home/chunwei/project/cinn2/cinn/ir/operation.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <map>
   #include <string>
   #include <utility>
   #include <vector>
   
   #include "cinn/ir/buffer.h"
   #include "cinn/ir/ir.h"
   #include "cinn/ir/tensor.h"
   
   namespace cinn {
   namespace ir {
   
   struct PlaceholderOp : public _Operation_ {
     std::vector<Expr> shape;
     Type dtype;
   
     static Operation Make(const std::string &name, const std::vector<Expr> &shape, Type dtype);
   
     const char *func_type() const override;
   
     static char const *__func_type__;
   };
   
   struct CallOp : public _Operation_ {
     const std::string &target() const;
   
     Expr call_expr;
   
     std::vector<Expr> &read_args();
     std::vector<Expr> &write_args();
     const std::vector<Expr> &read_args() const;
     const std::vector<Expr> &write_args() const;
     std::vector<Expr> args() const;
   
     Expr func;
   
     // the offset int the tuple of return values.
     int value_slot{-1};
   
     bool is_tuple_get{false};
   
     int num_value_slots{0};
   
     CallOp() = default;
   
     static Operation Make(const std::string &call_target, Expr call_op);
   
     const char *func_type() const override;
   
     static char const *__func_type__;
   };
   
   struct PrecedingViewOp : public _Operation_ {
     Expr tensor;
   
     int preceding_axis{-1};
   
     static Operation Make(const Tensor &tensor, int preceding_axis);
   
     const char *func_type() const override;
   
     static char const *__func_type__;
   };
   
   struct BufferShareOp : public _Operation_ {
     const char *func_type() const override;
     static Operation Make() { return Operation(new BufferShareOp); }
     static char const *__func_type__;
   };
   
   struct ComputeOp : public _Operation_ {
     using handle_t = std::function<Expr(const std::vector<Expr> &)>;
     std::vector<Var> reduce_axis;
     std::vector<Expr> shape;
     std::vector<Expr> body;
     handle_t producer_fn;
   
     ComputeOp() = default;
   
     static Operation Make(const std::string &name,
                           ComputeOp::handle_t handle,
                           const std::vector<Expr> &shape,
                           const std::vector<Expr> &domain,
                           const std::vector<Var> &reduce_axis           = {},
                           const std::map<std::string, IrNodeRef> &attrs = {},
                           const std::string &tag                        = "");
   
     const char *func_type() const override;
   
     static const char *__func_type__;
   };
   
   }  // namespace ir
   }  // namespace cinn
