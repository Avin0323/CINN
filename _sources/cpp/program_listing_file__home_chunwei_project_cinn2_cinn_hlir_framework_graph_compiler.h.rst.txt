
.. _program_listing_file__home_chunwei_project_cinn2_cinn_hlir_framework_graph_compiler.h:

Program Listing for File graph_compiler.h
=========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_hlir_framework_graph_compiler.h>` (``/home/chunwei/project/cinn2/cinn/hlir/framework/graph_compiler.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <memory>
   #include <string>
   #include <utility>
   #include <vector>
   
   #include "cinn/backends/compiler.h"
   #include "cinn/common/macros.h"
   #include "cinn/hlir/framework/graph.h"
   #include "cinn/hlir/framework/instruction.h"
   #include "cinn/hlir/framework/op_strategy.h"
   #include "cinn/hlir/framework/scope.h"
   #include "cinn/ir/lowered_func.h"
   #include "cinn/lang/packed_func.h"
   
   namespace cinn {
   namespace hlir {
   namespace framework {
   
   class Program {
    public:
     Program(const std::shared_ptr<Scope>& scope, std::vector<std::unique_ptr<Instruction>>&& instrs)
         : scope_(scope), instrs_(std::move(instrs)) {}
   
     void Execute() {
       for (auto& ins : instrs_) {
         auto in_args  = ins->GetInArgs();
         auto out_args = ins->GetOutArgs();
         VLOG(3) << "Op in args: ";
         for (auto& in : in_args) {
           VLOG(3) << in << " ";
         }
         VLOG(3) << "Op out args: ";
         for (auto& out : out_args) {
           VLOG(3) << out << " ";
         }
         ins->Run();
       }
     }
   
     size_t size() const { return instrs_.size(); }
   
    private:
     // We need to hold scope to assure tensors alive used in instructions.
     std::shared_ptr<Scope> scope_;
     std::vector<std::unique_ptr<Instruction>> instrs_;
   };
   
   class GraphCompiler final {
    public:
     GraphCompiler(Target target, const std::shared_ptr<Scope>& scope, const std::shared_ptr<Graph>& graph)
         : target_(std::move(target)), scope_(scope), graph_(graph), m_builder_(UniqName("module"), target) {}
   
     std::unique_ptr<Program> Build();
   
     void PrintFunc();
   
     const std::shared_ptr<Scope>& GetScope() const { return scope_; }
   
    private:
     ir::LoweredFunc GetOpFunc(const Node* node);
   
     std::string GenOpFuncName(const Node* node) const { return "fn_" + node->id(); }
   
     // TODO(haozech) add implementation
     std::vector<std::string> OpGetInputNames(const Node* node) const;
     // TODO(haozech) add implementation
     std::vector<std::string> OpGetOutputNames(const Node* node) const;
   
     std::vector<std::unique_ptr<Instruction>> BuildInstructions();
   
    private:
     Target target_;
     std::shared_ptr<Graph> graph_;
     std::shared_ptr<Scope> scope_;
   
     std::unique_ptr<backends::Compiler> compiler_;
   
     ir::Module::Builder m_builder_;
   
     CINN_DISALLOW_COPY_AND_ASSIGN(GraphCompiler);
   };
   
   std::shared_ptr<Scope> BuildScope(Target target,
                                     const std::shared_ptr<Graph>& graph,
                                     std::shared_ptr<Scope> scope = nullptr);
   
   }  // namespace framework
   }  // namespace hlir
   }  // namespace cinn
