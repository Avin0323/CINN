
.. _program_listing_file__home_chunwei_project_cinn2_cinn_ir_tensor.h:

Program Listing for File tensor.h
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_ir_tensor.h>` (``/home/chunwei/project/cinn2/cinn/ir/tensor.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <isl/cpp.h>
   
   #include <map>
   #include <memory>
   #include <set>
   #include <string>
   #include <unordered_map>
   #include <utility>
   #include <vector>
   
   #include "cinn/common/graph_utils.h"
   #include "cinn/ir/buffer.h"
   #include "cinn/ir/function_base.h"
   #include "cinn/lang/buffer.h"
   #include "cinn/poly/stage.h"
   
   namespace cinn {
   
   namespace ir {
   class Tensor;
   }  // namespace ir
   
   namespace lang {
   template <typename T>
   struct Placeholder;
   
   void InitReduceTensor(poly::StageMap stages,
                         const ir::Tensor& tensor,
                         const Target& target = common::DefaultHostTarget());
   }  // namespace lang
   
   namespace ir {
   namespace detail {
   constexpr bool LE(int a, int b) { return a <= b; }
   constexpr bool GE(int a, int b) { return a >= b; }
   
   }  // namespace detail
   
   class _Tensor_;
   class Tensor;
   
   class Tensor : public ir::IrNodeRef {
    public:
     Tensor() = default;
     explicit Tensor(ir::IrNode* n) : IrNodeRef(n) {}
     Tensor(const std::string& name,
            Type dtype,
            const std::vector<Expr>& shape,
            const std::vector<Expr>& domain,
            FunctionRef fn,
            const std::vector<Var>& reduce_axis = {});
   
     size_t ndims() const;
   
     // @{
     Expr operator()(const Expr& a) const { return operator()(std::vector<Expr>({a})); }
     template <typename... Args>
     inline typename std::enable_if<detail::GE(sizeof...(Args), 2), Expr>::type operator()(Args... args) const {
       return operator()({std::forward<Args>(args)...});
     }
     // @}
   
     Expr operator()(const std::vector<Expr>& indices) const;
   
     friend bool operator<(const Tensor& a, const Tensor& b);
   
     _Tensor_* self() { return operator->(); }
     const _Tensor_* self() const { return operator->(); }
   
     inline const _Tensor_* operator->() const { return As<_Tensor_>(); }
     inline _Tensor_* operator->() { return As<_Tensor_>(); }
   
     inline operator Expr() const { return Expr(get()); }
   };
   
   std::string GenReduceInitTensorNameOf(const std::string& tensor_name);
   
   class ComputeOp;
   class PlaceholderOp;
   struct ReadCacheRelation;
   struct WriteCacheRelation;
   
   class _Tensor_ : public ExprNode<_Tensor_> {
    public:
     std::vector<Expr> shape;
     // TODO(Superjomn) support ISL domain.
     std::vector<Expr> domain;
   
     std::vector<Var> reduce_axis;
     FunctionRef operation;
     std::string name;
     Buffer buffer;
   
     std::vector<Expr> domain_with_reduce_axis() const;
     const std::vector<Expr>& domain_without_reduce_axis() const { return domain; }
   
     static Tensor Make(const std::string& name,
                        Type dtype,
                        const std::vector<Expr>& shape,
                        const std::vector<Expr>& domain,
                        FunctionRef fn,
                        const std::vector<Var>& reduce_axis = {});
   
     void Verify() const override;
   
     bool IsReduceInited(poly::StageMap stages) const;
   
     bool is_tuple() const;
     bool is_tuple_get() const;
   
     Tensor TupleGet(int offset) const;
   
     std::set<std::string> GetDependTensorNames() const;
   
     bool IsDependOnStatement(std::string_view statement);
   
     std::set<std::string> DependingTensorNames();
   
     ir::Tensor Reshape(const std::vector<Expr>& shape, poly::StageMap stages) const;
   
     ir::Tensor ReshapeCopied(const std::vector<Expr>& shape, poly::StageMap stages) const;
   
     bool HasSameShapeWith(const Tensor& other) const;
   
     // @{
     bool is_compute_node() const;
     bool is_placeholder_node() const;
     bool is_call_node() const;
     bool is_extern_call_node() const;
     bool is_preceding_view_node() const;
     bool is_buffer_shared_node() const;
     const char* operation_type() const;
     ComputeOp* get_compute_op() const;
     PlaceholderOp* get_placeholder_op() const;
     // @}
   
     Expr body() const;
     Expr* mutable_body();
     Expr tensor_store_expanded_body();
   
     Expr inline_expanded(const std::vector<Expr>& indices);
   
     bool contains_reduce_axis() const { return !reduce_axis.empty(); }
     bool is_reduce_tensor() const { return contains_reduce_axis(); }
     bool is_reduce_sum() const;
     bool is_reduce_mul() const;
     Expr GetReduceInitVal() const;
   
     std::vector<Expr*> expr_fields() override;
     std::vector<const Expr*> expr_fields() const override;
   
     const std::vector<Var>& axis() const;
   
     std::vector<Var> axis_with_reduce() const;
   
     const std::set<std::string>& buffer_depended_tensor_names() const { return buffer_depended_tensor_names_; }
   
     static const IrNodeTy _node_type_ = IrNodeTy::_Tensor_;
   
     _Tensor_() : ExprNode<_Tensor_>(Float(32)) {}
   
     bool has_expression() const;
   
     ~_Tensor_();
   
     bool Uses(const ir::Tensor& other);
   
     void Bind(lang::Buffer& buffer);  // NOLINT
     void Bind(const Buffer& buffer);
     void UnBind(lang::Buffer& buffer);  // NOLINT
   
     void WithBuffer(const Type& type = Void());
     void WithBuffer(const std::string& memory_type, const Type& type = Void());
   
    private:
     void InitAxis() const;
   
     isl::set GenerateIslDomain() const;
   
     ir::Tensor InitReduction(poly::StageMap stages, const Target& target = common::DefaultHostTarget()) const;
   
     std::set<std::string> buffer_depended_tensor_names_;
   
     mutable std::vector<Var> axis_;
   
     friend Shared<poly::Stage> CreateStage(Tensor tensor);
   
     friend void lang::InitReduceTensor(poly::StageMap stages, const ir::Tensor& tensor, const Target& target);
   };
   
   Shared<poly::Stage> CreateStage(Tensor tensor);
   
   class _Operation_;
   class Operation : public FunctionRef {
    public:
     Operation() = default;
     explicit Operation(IrNode* n) : FunctionRef(n) {}
   
     inline const _Operation_* operator->() const { return reinterpret_cast<_Operation_*>(get()); }
     inline _Operation_* operator->() { return reinterpret_cast<_Operation_*>(get()); }
   
     // Tensor output(size_t i) const;
   
     std::string name;
   };
   
   class _Operation_ : public ir::FunctionBase {
    public:
     std::string name;
     std::string tag;
     std::map<std::string, IrNodeRef> attrs;
   
     const std::string& func_name() const final { return name; }
   
     void Verify() const override {}
   
     virtual const char* func_type() const = 0;
   };
   
   }  // namespace ir
   }  // namespace cinn
   
   namespace std {
   
   template <>
   struct hash<cinn::ir::Tensor> {
     inline size_t operator()(const cinn::ir::Tensor& x) {
       // We treat the tensor's name as the unique identifier.
       return std::hash<std::string>()(x->name);
     }
   };
   
   }  // namespace std
