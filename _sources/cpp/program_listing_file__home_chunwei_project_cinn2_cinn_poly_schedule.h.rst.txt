
.. _program_listing_file__home_chunwei_project_cinn2_cinn_poly_schedule.h:

Program Listing for File schedule.h
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_poly_schedule.h>` (``/home/chunwei/project/cinn2/cinn/poly/schedule.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <algorithm>
   #include <map>
   #include <memory>
   #include <string>
   #include <unordered_map>
   #include <utility>
   #include <vector>
   
   #include "cinn/common/common.h"
   #include "cinn/ir/tensor.h"
   #include "cinn/poly/graph.h"
   #include "cinn/poly/isl_utils.h"
   #include "cinn/poly/map.h"
   #include "cinn/poly/stage.h"
   
   namespace cinn {
   namespace poly {
   
   struct TimeDim {
     int time;
     std::string dim;
   
     TimeDim() = default;
     TimeDim(const std::string &dim, int time) : dim(dim), time(time) { CHECK(!dim.empty()); }
   };
   
   class ScheduleGraphNode;
   struct ScheduleGraph : public common::Graph {};
   
   struct TimeSchedule {
     TimeSchedule(const std::string &id, const std::vector<std::string> &dims);
   
     void ResizeTimeSpace(int size);
   
     void OrderAfter(const TimeSchedule &other, int level);
   
     size_t space_size() const { return time_dims_.size(); }
   
     const std::string &id() const;
   
     isl::map to_isl(isl::ctx ctx) const;
   
     std::string __str__() const;
   
     std::vector<std::string> final_axis_names() const;
   
     std::vector<std::string> domain_dims;
     int duplicate_id{};
   
     constexpr static int kMaxDims = 50;
   
    private:
     int root_time_{0};
     std::vector<TimeDim> time_dims_;
     std::string id_;
   };
   
   struct ScheduleGroup;
   struct Schedule {
     std::vector<ScheduleGroup> groups;
     std::map<std::string, isl::map> schedule;
   };
   
   class SchedulerBase {
    public:
     static std::vector<std::string> WrapIteratorNames(const std::vector<std::string> &names);
   
     SchedulerBase &After(const Stage &a, const Stage &b, int level);
     SchedulerBase &Before(const Stage &a, const Stage &b, int level);
   
     std::map<std::string, isl::map> schedule_map() const;
   
     const std::vector<std::string> &detailed_dimension_names() const { return detailed_dimension_names_; }
   
    protected:
     void AddStage(const Stage &x);
   
     void FinishStageAdd();
   
     bool finalized() const { return registration_finalized_; }
     int space_size() const { return space_size_; }
   
    protected:
     int space_size_{0};
     mutable isl::ctx ctx_{Context::Global().isl_ctx()};
     mutable ScheduleGraph schedule_graph_;
     // Record the longest dimensions(of some stage) to be the final detailed dimension names. It might be used for ISL AST
     // to set iterator names and generate readable code.
     mutable std::vector<std::string> detailed_dimension_names_;
   
    private:
     bool registration_finalized_{false};
   };
   
   enum class ScheduleKind {
     Naive = 0,
     Poly = 1,
   };
   
   // std::unique_ptr<Schedule> CreateSchedule(const ir::Tensor &tensor, ScheduleKind schedule_kind = ScheduleKind::Poly);
   std::unique_ptr<Schedule> CreateSchedule(const std::vector<Stage *> &stages,
                                            ScheduleKind schedule_kind = ScheduleKind::Poly,
                                            const std::vector<std::pair<std::string, std::string>> &extra_links = {});
   
   // std::vector<Stage *> GatherStagesInTensors(const std::vector<ir::Tensor> &xs, bool with_placeholder = false);
   
   struct ScheduleGraphEdge : public common::GraphEdge {
     ScheduleGraphEdge(common::GraphNode *a, common::GraphNode *b) : common::GraphEdge(a, b) {}
   
     int level;
   };
   
   struct ScheduleGraphNode : public common::GraphNode {
     TimeSchedule time_schedule;
     Stage *stage{};
   
     // std::string id() const override { return std::to_string(reinterpret_cast<size_t>(this)); }
     std::string id() const override { return time_schedule.id(); }
   
     explicit ScheduleGraphNode(const std::string &id, const std::vector<std::string> &dims, const Stage *stage)
         : time_schedule(id, dims), stage(const_cast<Stage *>(stage)) {}
   
     const char *type_info() const override { return __type_info__; }
   
     static const char *__type_info__;
   };
   
   struct ScheduleGroup {
     std::vector<Shared<ScheduleGraphNode>> nodes;
     std::vector<std::string> dimension_names;
   };
   
   std::map<std::string, isl::map> CollectScheduleMapFromGroup(const ScheduleGroup &group);
   
   }  // namespace poly
   }  // namespace cinn
