
.. _program_listing_file__home_chunwei_project_cinn2_cinn_poly_stage.h:

Program Listing for File stage.h
================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_poly_stage.h>` (``/home/chunwei/project/cinn2/cinn/poly/stage.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <glog/logging.h>
   #include <isl/cpp.h>
   
   #include <algorithm>
   #include <map>
   #include <memory>
   #include <set>
   #include <string>
   #include <tuple>
   #include <utility>
   #include <vector>
   
   #include "cinn/common/common.h"
   #include "cinn/ir/ir.h"
   #include "cinn/ir/tensor.h"
   #include "cinn/poly/domain.h"
   #include "cinn/poly/map.h"
   
   namespace cinn {
   namespace poly {
   using ir::DeviceAPI;
   
   struct ComputeAtRelation;
   
   enum class ScopeKind {
     kLocal  = 0,
     kShared = 1,
   };
   
   class StageMap;
   
   struct StageForloopInfo {
     StageForloopInfo() = default;
     StageForloopInfo(ir::ForType for_type, ir::DeviceAPI device, uint8_t offset)
         : for_type(for_type), device(device), offset(offset) {}
   
     ir::ForType for_type;
     uint8_t offset;
     ir::DeviceAPI device;
   };
   
   struct ReadCacheRelation {
     std::string cache_name;
     std::vector<std::string> readers;
   };
   
   struct WriteCacheRelation {
     std::string cache_name;
   };
   
   struct ComputeAtInfo {
     ComputeAtInfo(const std::string& consumer_tensor_name,
                   const std::string& producer_tensor_name,
                   const std::vector<int>& adjusted_producer_shape,
                   const std::vector<int>& preceding_offset_for_producer_load,
                   int level)
         : consumer_tensor_name(consumer_tensor_name),
           producer_tensor_name(producer_tensor_name),
           adjusted_producer_shape(adjusted_producer_shape),
           preceding_offset_for_producer_load(preceding_offset_for_producer_load),
           level(level) {}
   
     std::string consumer_tensor_name;
     std::string producer_tensor_name;
     std::vector<int> adjusted_producer_shape;
     std::vector<int> preceding_offset_for_producer_load;
     int level{-1};
   };
   
   struct TensorScheduleMeta {
     std::unique_ptr<ReadCacheRelation> read_cache_relation;
     std::unique_ptr<WriteCacheRelation> write_cache_relation;
   
     std::vector<ComputeAtInfo> compute_at_infos;
   
     bool compute_inline{false};
   
     std::set<std::string> tensors_to_share_buffer_with;
   };
   
   class Stage : public Object {
    public:
     static Shared<Stage> New(const isl::set& domain, Expr expr = Expr(), ir::_Tensor_* tensor = nullptr);
   
     TensorScheduleMeta meta;
   
     const char* id() const;
   
     const Expr& expr() const { return expr_; }
   
     Iterator axis(int i) const;
     Iterator axis(const std::string& i) const;
   
     std::vector<std::string> axis_names() const;
   
     ir::_Tensor_* tensor() { return tensor_; }
   
     void ComputeInline();
   
     bool inlined() const { return meta.compute_inline; }
   
     void ShareBufferWith(Stage* other);
   
     // @{
     std::tuple<Iterator, Iterator>  //
     Split(const Iterator& level, int factor);
     std::tuple<Iterator, Iterator>  //
     Split(const std::string& level, int factor);
     std::tuple<Iterator, Iterator>  //
     Split(int level, int factor);
     // @}
   
     void Reorder(const std::vector<Iterator>& order);
   
     std::tuple<Iterator, Iterator, Iterator, Iterator>  //
     Tile(const Iterator& level0, const Iterator& level1, int factor0, int factor1);
     std::tuple<Iterator, Iterator, Iterator, Iterator>  //
     Tile(int level0, int level1, int factor0, int factor1);
   
     void Vectorize(int level, int factor);
     void Vectorize(const std::string& axis, int factor);
     void Vectorize(const Iterator& axis, int factor);
   
     void Unroll(int level);
     void Unroll(const std::string& level);
     void Unroll(const Iterator& level);
   
     void Bind(int level, const std::string& axis);
   
     enum ComputeAtKind {
       kComputeAtAuto,
       kComputeAtBefore,
       kComputeAtAfter,
     };
   
     void ComputeAt(Stage* other,
                    int level,
                    ComputeAtKind kind                    = kComputeAtAuto,
                    const std::string& cached_tensor_name = "");
   
     std::tuple<Iterator, Iterator>  //
     Skew(const Iterator& i, const Iterator& j, int factor);
   
     void CtrlDepend(const ir::Tensor& t);
     const std::set<ir::Tensor>& ctrl_depends() const;
   
     ir::Tensor CacheRead(const std::string& memory_type, const std::vector<ir::Tensor>& readers, poly::StageMap stages);
   
     ir::Tensor CacheWrite(const std::string& memory_type, poly::StageMap stages);
   
     void SetScope(ScopeKind scope) { scope_ = scope; }
   
     ScopeKind scope() const { return scope_; }
   
     Iterator Fuse(const Iterator& level0, const Iterator& level1);
     Iterator Fuse(int level0, int level1);
     Iterator Fuse(const std::string& level0, const std::string& level1);
   
     const isl::set& domain() const { return domain_; }
     const isl::map& transform() const { return transform_; }
     isl::set transformed_domain() const;
   
     // Dealing with the `ComputateAt` transform.
     std::vector<ComputeAtRelation> compute_ats() const;
   
     std::string ith_dim_name(int level);
     Iterator ith_iterator(int level);
   
     int GetTransformedLevel(int level);
   
     std::vector<std::string> input_statements() const;
   
     virtual const char* type_info() const { return __type_info__; }
   
     inline const ir::VectorizeInfo& vectorize_info() const { return vectorize_info_; }
     inline const std::set<int>& unroll_info() const { return unroll_info_; }
   
     /*
     const std::set<std::string>& extra_depend_stages() const { return extra_depend_stages_; }
     void set_extra_depend_stages(const std::set<std::string>& x) { extra_depend_stages_ = x; }
     void add_extra_depend_stage(const std::string& statement) { extra_depend_stages_.insert(statement); }
      */
   
     const std::map<int /*level*/, StageForloopInfo>& forloop_infos() const { return forloop_infos_; }
   
     bool has_expression() const;
   
     Stage() = default;
   
     void ComputeAtSchedule(Stage* other, int level, ComputeAtKind kind = kComputeAtAuto);
   
     ir::Tensor LookupCtrlDepend(const std::string& tensor_name) const;
   
    private:
     explicit Stage(const isl::set& domain, Expr expr = Expr(), ir::_Tensor_* tensor = nullptr);
   
     void InitTransform();
   
     void AddForloopInfo(int level, const StageForloopInfo& info);
   
     void LockAxis(uint32_t level);
     void UnlockAxis(uint32_t level);
     bool is_axis_locked(uint32_t level) const;
     void AssertAxisIsNotLocked(uint32_t level);
   
     inline int n_in_dims() const { return isl_map_dim(transform_.get(), isl_dim_in); }
     inline int n_out_dims() const { return isl_map_dim(transform_.get(), isl_dim_out); }
   
     static constexpr char* __type_info__ = "Stage";
   
    private:
     isl::set domain_;
     isl::map transform_;
     Expr expr_;
     // this compute_at some other stages.
     std::map<std::string, ComputeAtRelation> compute_ats_;
     ir::VectorizeInfo vectorize_info_;
     std::set<int> unroll_info_;
     std::map<int /*level*/, StageForloopInfo> forloop_infos_;
     ir::_Tensor_* tensor_{};
     ScopeKind scope_{ScopeKind::kLocal};
   
     std::set<ir::Tensor> ctrl_depends_;
   
     std::set<int> locked_axis_;
   
     friend isl_map* __isl_give GatherAccesses(Stage* stage, const std::string& tensor_name);
     friend class PolyGroupScheduler;
   };
   
   std::vector<std::pair<std::string, std::string>> ExtractExtraDepLinksFromStages(const std::vector<Stage*>& stages);
   
   struct ComputeAtRelation {
     Shared<Stage> stage;
     int level{-1};
   
     bool IsCompatible(Stage* self);
   };
   
   inline std::string InnerName(const std::string& name);
   inline std::string InnerName(const Iterator& iterator);
   inline std::string OuterName(const std::string& name);
   inline std::string OuterName(const Iterator& iterator);
   
   inline Iterator DefaultIterator(int i) { return Iterator(common::axis_name(i)); }
   
   std::vector<isl::map> GatherAccesses(const Stage* stage, const std::string& tensor_name);
   
   class _StageMap_ : public Object {
    public:
     // @{
     Stage* operator[](const ir::Tensor& tensor);
     const Stage* operator[](const ir::Tensor& tensor) const;
     Stage* operator[](const ir::_Tensor_* tensor);
     const Stage* operator[](const ir::_Tensor_* tensor) const;
     // @}
   
     Stage* Insert(const ir::Tensor& key, Stage* stage);
     Stage* InsertLazily(const ir::Tensor& key);
   
     Stage* Lookup(const std::string& name) const;
   
     inline size_t size() const { return data_.size(); }
   
     const char* type_info() const override { return __type_info__; }
   
     static constexpr const char* __type_info__ = "StageMap";
   
    private:
     std::unordered_map<std::string, Shared<Stage>> data_;
   
     friend class StageMap;
   };
   
   class StageMap : public Shared<_StageMap_> {
    public:
     StageMap() : Shared(new _StageMap_) {}
   
     Stage* operator[](const ir::Tensor& tensor) { return (*self())[tensor]; }
     const Stage* operator[](const ir::Tensor& tensor) const { return (*self())[tensor]; }
     Stage* operator[](const ir::_Tensor_* tensor) { return (*self())[tensor]; }
     const Stage* operator[](const ir::_Tensor_* tensor) const { return (*self())[tensor]; }
   
     auto begin() const { return self()->data_.begin(); }
     auto end() const { return self()->data_.end(); }
   };
   
   StageMap CreateStages(const std::vector<ir::Tensor>& tensors);
   
   }  // namespace poly
   }  // namespace cinn
