
.. _program_listing_file__home_chunwei_project_cinn2_cinn_ir_ir_operators.h:

Program Listing for File ir_operators.h
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_ir_ir_operators.h>` (``/home/chunwei/project/cinn2/cinn/ir/ir_operators.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <vector>
   
   #include "cinn/common/ir_util.h"
   #include "cinn/ir/ir.h"
   
   namespace cinn {
   namespace ir {
   
   //-- left hand --
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator+(Expr a, POD b) {
     return Add::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator-(Expr a, POD b) {
     return Sub::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator*(Expr a, POD b) {
     return Mul::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator/(Expr a, POD b) {
     return Div::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator%(Expr a, POD b) {
     return Mod::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator<(Expr a, POD b) {
     return LT::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator<=(Expr a, POD b) {
     return LE::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator>(Expr a, POD b) {
     return GT::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator>=(Expr a, POD b) {
     return GE::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator==(Expr a, POD b) {
     return EQ::Make(Expr(a), Expr(b));
   }
   
   //- right hand --
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator+(POD a, Expr b) {
     return Add::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator-(POD a, Expr b) {
     return Sub::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator*(POD a, Expr b) {
     return Mul::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator/(POD a, Expr b) {
     return Div::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator%(POD a, Expr b) {
     return Mod::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator<(POD a, Expr b) {
     return LT::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator<=(POD a, Expr b) {
     return LE::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator>(POD a, Expr b) {
     return GT::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator>=(POD a, Expr b) {
     return GE::Make(Expr(a), Expr(b));
   }
   template <typename POD, typename = typename std::enable_if<std::is_pod<POD>::value>::type>
   Expr operator==(POD a, Expr b) {
     return EQ::Make(Expr(a), Expr(b));
   }
   
   //--
   inline Expr operator+(Expr a, Expr b) { return Add::Make(a, b); }
   inline Expr operator-(Expr a, Expr b) { return Sub::Make(a, b); }
   inline Expr operator*(Expr a, Expr b) { return Mul::Make(a, b); }
   inline Expr operator/(Expr a, Expr b) { return Div::Make(a, b); }
   inline Expr operator%(Expr a, Expr b) { return Mod::Make(a, b); }
   
   inline Expr operator&&(Expr a, Expr b) { return And::Make(Expr(a), Expr(b)); }
   inline Expr operator||(Expr a, Expr b) { return Or::Make(Expr(a), Expr(b)); }
   inline Expr operator>=(Expr a, Expr b) { return GE::Make(Expr(a), Expr(b)); }
   inline Expr operator<=(Expr a, Expr b) { return LE::Make(Expr(a), Expr(b)); }
   inline Expr operator>(Expr a, Expr b) { return GT::Make(Expr(a), Expr(b)); }
   inline Expr operator<(Expr a, Expr b) { return LT::Make(Expr(a), Expr(b)); }
   
   inline Expr operator-(Expr a) { return Minus::Make(Expr(a)); }
   inline Expr operator!(Expr a) { return Not::Make(Expr(a)); }
   
   Expr operator<<(Expr a, Expr b);
   Expr operator>>(Expr a, Expr b);
   Expr operator^(Expr a, Expr b);
   Expr operator|(Expr a, Expr b);
   Expr operator&(Expr a, Expr b);
   Expr operator~(Expr a);
   
   }  // namespace ir
   }  // namespace cinn
