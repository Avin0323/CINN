
.. _program_listing_file__home_chunwei_project_cinn2_cinn_common_ir_util.h:

Program Listing for File ir_util.h
==================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_common_ir_util.h>` (``/home/chunwei/project/cinn2/cinn/common/ir_util.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <map>
   #include <memory>
   #include <string>
   #include <unordered_map>
   #include <vector>
   
   #include "cinn/ir/ir.h"
   
   namespace cinn {
   namespace common {
   
   Expr IndiceToAbsOffset(const std::vector<Expr> &shape, const std::vector<Expr> &indices);
   Expr IndiceToAbsOffset(const std::vector<int> &shape, const std::vector<Expr> &indices);
   
   Expr PrecedingAxisToAbsOffset(const std::vector<Expr> &shape, int preceding_n_axis);
   
   Expr CastIfNeeded(Expr body, Type type);
   
   void Substitute(Expr *expr, const std::map<const ir::_Var_ *, Expr> &var_map);
   
   template <typename T>
   Expr make_const(Type t, T v);
   
   std::vector<Expr *> GetForloopStackToStore(Expr *expr, const std::string &tensor_name);
   
   // make const
   // @{
   inline Expr make_const(int32_t x) { return make_const(Int(32), static_cast<int64_t>(x)); }
   inline Expr make_const(int64_t x) { return make_const(Int(64), static_cast<int64_t>(x)); }
   inline Expr make_const(float x) { return make_const(Float(32), static_cast<double>(x)); }
   inline Expr make_const(double x) { return make_const(Float(64), static_cast<double>(x)); }
   inline Expr make_const(bool x) { return make_const(Bool(1), static_cast<bool>(x)); }
   // @}
   
   // @{
   template <typename T = int32_t>
   inline Expr make_zero() {
     return make_const(static_cast<T>(0));
   }
   template <typename T = int32_t>
   inline Expr make_one() {
     return make_const(static_cast<T>(1));
   }
   inline Expr make_bool(bool x) { return common::make_shared<ir::UIntImm>(Bool(), x); }
   // @}
   
   void CheckTensorUniqueInExpr(Expr expr);
   
   void CheckBufferUniqueInExpr(Expr expr);
   
   std::vector<std::string> GatherItersToTensorProducer(const std::string &target_tensor_name, Expr *expr);
   
   bool is_zero(Expr v);
   
   bool MathEqual(const Expr &a, const Expr &b);
   
   Expr select(Expr cond, Expr true_value, Expr false_value);
   
   Expr and_all(const std::vector<Expr> &conds);
   
   Expr or_any(const std::vector<Expr> &conds);
   
   Expr cast(Expr e, Type type);
   
   Expr max(Expr a, Expr b);
   
   Expr min(Expr a, Expr b);
   
   template <typename T>
   Expr make_const(Type t, T v) {
     if (t.is_vector()) {
       if (t.type() == Type::type_t::Int) {
         return ir::Broadcast::Make(make_shared<ir::IntImm>(t.ElementOf(), v), t.lanes());
       } else {
         return ir::Broadcast::Make(make_shared<ir::FloatImm>(t.ElementOf(), v), t.lanes());
       }
     } else {
       if (t.type() == Type::type_t::Int) {
         return make_shared<ir::IntImm>(t, v);
       } else {
         return make_shared<ir::FloatImm>(t, v);
       }
     }
     return Expr();
   }
   
   template <typename FuncOp>
   Expr FoldExpr(FuncOp func_op, const std::vector<Expr> &values) {
     Expr init_value;
     for (const Expr &val : values) {
       if (!init_value.defined()) {
         init_value = val;
       } else {
         init_value = func_op(val, init_value);
       }
     }
     return init_value;
   }
   
   }  // namespace common
   }  // namespace cinn
