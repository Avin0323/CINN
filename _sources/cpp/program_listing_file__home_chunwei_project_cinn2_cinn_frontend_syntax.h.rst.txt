
.. _program_listing_file__home_chunwei_project_cinn2_cinn_frontend_syntax.h:

Program Listing for File syntax.h
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_frontend_syntax.h>` (``/home/chunwei/project/cinn2/cinn/frontend/syntax.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <glog/logging.h>
   
   #include <memory>
   #include <string>
   #include <tuple>
   #include <unordered_map>
   #include <variant>
   #include <vector>
   
   #include "cinn/common/common.h"
   #include "cinn/common/context.h"
   #include "cinn/common/object.h"
   #include "cinn/common/type.h"
   #include "cinn/hlir/framework/node.h"
   #include "cinn/hlir/framework/scope.h"
   
   namespace cinn {
   namespace frontend {
   
   struct Program;
   struct Variable;
   
   struct _Variable_ : public common::Object {
     std::string id;
     common::Type type;
     std::vector<int> shape;
   
     const char* type_info() const override { return __type_info__; }
     static constexpr char* __type_info__ = "cinn_frontend_variable";
   };
   
   struct Variable : public common::Shared<_Variable_> {
     explicit Variable(std::string_view id_hint = "") : common::Shared<_Variable_>(common::make_shared<_Variable_>()) {
       if (!id_hint.empty()) CheckVarNameValid(id_hint);
       get()->id = id_hint.empty() ? common::Context::Global().NewName("var") : id_hint;
     }
   
     void set_id(const std::string& id) { operator->()->id = id; }
   
     _Variable_* operator->() { return get(); }
     const _Variable_* operator->() const { return get(); }
   };
   
   class Placeholder {
    public:
     Placeholder(const common::Type& type, const std::vector<int>& shape, std::string_view id_hint = "") {
       if (!id_hint.empty()) CheckVarNameValid(std::string(id_hint));
       id_         = id_hint.empty() ? common::Context::Global().NewName("placeholder") : id_hint;
       var_        = Variable(id_);
       var_->shape = shape;
       var_->type  = type;
     }
   
     const std::vector<int>& shape() const { return var_->shape; }
   
     Type type() const { return var_->type; }
   
     std::string_view id() const { return id_; }
   
     operator Variable() const;
   
     Program* parent_program() { return parent_program_; }
   
    private:
     Variable var_;
     std::string id_{};
     Program* parent_program_{};
   };
   
   struct _Instruction_ : public common::Object {
     using attr_t = hlir::framework::AttrType;
   
     std::string op_type;
     std::unordered_map<std::string, attr_t> attrs;
     std::vector<std::pair<std::string, attr_t>> attrs_ordered;
     std::vector<Variable> inputs;
     std::vector<Variable> outputs;
     Program* parent_program{};
   
     const char* type_info() const override { return __type_info__; }
   
     std::string debug_string() const;
   
     static constexpr char* __type_info__ = "cinn_frontend_instruction";
   };
   
   struct Instruction : public common::Shared<_Instruction_> {
     explicit Instruction(std::string_view op_type, const std::vector<Variable>& inputs = {}, Program* parent = nullptr);
   
     void SetInputs(const std::vector<Variable>& vars) { get()->inputs = vars; }
     const std::vector<Variable>& GetOutputs() const { return get()->outputs; }
     const Variable& GetOutput(size_t offset) const {
       CHECK_LT(offset, get()->outputs.size());
       return GetOutputs()[offset];
     }
   
     template <typename T>
     void SetAttr(const std::string& key, const T& v) {
       get()->attrs[key] = v;
     }
   
     template <typename T>
     T GetAttrs(const std::string& key) {
       auto it = get()->attrs.find(key);
       CHECK(it != get()->attrs.end()) << "No attribute called [" << key << "]";
       return std::get<T>(it->second);
     }
   
    private:
     // Generate outputs according to op's declaration.
     void PrepareOutputs();
   };
   
   struct Program {
     using attr_t = hlir::framework::NodeAttr::attr_t;
     void SetInputs(const std::vector<Variable>& xs);
     Variable add(const Variable& a, const Variable& b);
   
     Variable mul(const Variable& a, const Variable& b, int x_num_col_dims = 1, int y_num_col_dims = 1);
   
     Variable mulbias(
         const Variable& a, const Variable& b, const Variable& c, int x_num_col_dims = 1, int y_num_col_dims = 1);
   
     Variable elementwise_add(const Variable& a, const Variable& b, int axis = -1);
   
     Variable elementwise_mul(const Variable& a, const Variable& b, int axis = -1);
   
     Variable relu(const Variable& a);
     Variable relu6(const Variable& a);
   
     Variable conv2d(const Variable& a, const Variable& b, const std::unordered_map<std::string, attr_t>& attr_store);
     Variable depthwise_conv2d(const Variable& a,
                               const Variable& b,
                               const std::unordered_map<std::string, attr_t>& attr_store);
     Variable pool2d(const Variable& a, const std::unordered_map<std::string, attr_t>& attr_store);
   
     Variable batchnorm(const Variable& a,
                        const Variable& scale,
                        const Variable& bias,
                        const Variable& mean,
                        const Variable& variance,
                        const std::unordered_map<std::string, attr_t>& attr_store);
   
     Variable scale(const Variable& a, const std::unordered_map<std::string, attr_t>& attr_store);
   
     Variable softmax(const Variable& a, const std::unordered_map<std::string, attr_t>& attr_store);
   
     Variable sigmoid(const Variable& a);
   
     Variable slice(const Variable& a, const std::unordered_map<std::string, attr_t>& attr_store);
   
     Variable dropout_infer(const Variable& a, const std::unordered_map<std::string, attr_t>& attr_store);
   
     Instruction& operator[](size_t i);
     const Instruction& operator[](size_t i) const;
   
     inline size_t size() const { return instrs_.size(); }
   
     void Validate() const;
   
     void AppendInstruction(const Instruction& other) { instrs_.push_back(other); }
   
    private:
     std::vector<Instruction> instrs_;
   
     std::vector<Variable> inputs_;
   };
   
   std::tuple<std::unique_ptr<Program>,
              std::unordered_map<std::string, Variable>,
              std::unordered_map<std::string, std::string>>
   LoadPaddleProgram(const std::string& model_dir,
                     hlir::framework::Scope* scope,
                     bool is_combined,
                     const common::Target& target = common::DefaultHostTarget());
   
   std::ostream& operator<<(std::ostream& os, const Variable& x);
   std::ostream& operator<<(std::ostream& os, const Instruction& instr);
   std::ostream& operator<<(std::ostream& os, const Program& program);
   
   }  // namespace frontend
   }  // namespace cinn
