
.. _program_listing_file__home_chunwei_project_cinn2_cinn_ir_ir.h:

Program Listing for File ir.h
=============================

|exhale_lsh| :ref:`Return to documentation for file <file__home_chunwei_project_cinn2_cinn_ir_ir.h>` (``/home/chunwei/project/cinn2/cinn/ir/ir.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #pragma once
   
   #include <algorithm>
   #include <map>
   #include <memory>
   #include <set>
   #include <string>
   #include <variant>
   #include <vector>
   
   #include "cinn/common/shared.h"
   #include "cinn/common/type.h"
   #include "cinn/ir/function_base.h"
   #include "cinn/ir/ir_base.h"
   #include "cinn/utils/small_vector.h"
   
   namespace cinn {
   
   namespace poly {
   class Stage;
   }  // namespace poly
   
   namespace ir {
   struct Buffer;
   struct LoweredFunc;
   class Module;
   
   using common::Object;
   using common::Shared;
   
   struct Cast : public ExprNode<Cast> {
     Cast() : ExprNode(1) {}
   
     static Expr Make(Type t, Expr v);
   
     Expr& v() { return operand(0); }
     const Expr& v() const { return operand(0); }
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Cast;
   };
   
   struct Add : public BinaryOpNode<Add> {
     Add(Expr a, Expr b);
   
     static Expr Make(Expr a, Expr b);
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Add;
   };
   
   struct Sub : public BinaryOpNode<Sub> {
     Sub(Expr a, Expr b) : BinaryOpNode<Sub>(a.type(), a, b) {}
   
     static Expr Make(Expr a, Expr b);
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Sub;
   };
   
   struct Mul : public BinaryOpNode<Mul> {
     Mul(Expr a, Expr b) : BinaryOpNode<Mul>(a.type(), a, b) {}
   
     static Expr Make(Expr a, Expr b);
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Mul;
   };
   
   struct Div : public BinaryOpNode<Div> {
     Div(Expr a, Expr b) : BinaryOpNode<Div>(a.type(), a, b) {}
   
     static Expr Make(Expr a, Expr b);
     void Verify() const override;
     static const IrNodeTy _node_type_ = IrNodeTy::Div;
   };
   
   struct Mod : public BinaryOpNode<Mod> {
     Mod(Expr a, Expr b) : BinaryOpNode<Mod>(a.type(), a, b) {}
   
     static Expr Make(Expr a, Expr b);
     void Verify() const override;
     static const IrNodeTy _node_type_ = IrNodeTy::Mod;
   };
   
   struct Min : public BinaryOpNode<Min> {
     Min(Expr a, Expr b) : BinaryOpNode<Min>(a.type(), a, b) {}
   
     static Expr Make(Expr a, Expr b);
     void Verify() const override;
     static const IrNodeTy _node_type_ = IrNodeTy::Min;
   };
   
   struct Max : public BinaryOpNode<Max> {
     Max(Expr a, Expr b) : BinaryOpNode<Max>(a.type(), a, b) {}
   
     static Expr Make(Expr a, Expr b);
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Max;
   };
   
   struct EQ : public BinaryOpNode<EQ> {
     EQ(Expr a, Expr b) : BinaryOpNode<EQ>(a.type(), a, b) {}
   
     Type type() const { return Bool(a()->type().lanes()); }
   
     static Expr Make(Expr a, Expr b);
     void Verify() const override;
     static const IrNodeTy _node_type_ = IrNodeTy::EQ;
   };
   
   struct NE : public BinaryOpNode<NE> {
     NE(Expr a, Expr b) : BinaryOpNode<NE>(a.type(), a, b) {}
   
     Type type() const { return Bool(a()->type().lanes()); }
   
     static Expr Make(Expr a, Expr b);
     void Verify() const override;
     static const IrNodeTy _node_type_ = IrNodeTy::NE;
   };
   
   struct LT : public BinaryOpNode<LT> {
     LT(Expr a, Expr b) : BinaryOpNode<LT>(a.type(), a, b) {}
   
     Type type() const { return Bool(a()->type().lanes()); }
   
     static Expr Make(Expr a, Expr b);
     void Verify() const override;
     static const IrNodeTy _node_type_ = IrNodeTy::LT;
   };
   
   struct LE : public BinaryOpNode<LE> {
     LE(Expr a, Expr b) : BinaryOpNode<LE>(a.type(), a, b) {}
   
     Type type() const { return Bool(a()->type().lanes()); }
   
     static Expr Make(Expr a, Expr b);
     void Verify() const override;
     static const IrNodeTy _node_type_ = IrNodeTy::LE;
   };
   
   struct GT : public BinaryOpNode<GT> {
     GT(Expr a, Expr b) : BinaryOpNode<GT>(a.type(), a, b) {}
   
     Type type() const { return Bool(a()->type().lanes()); }
   
     static Expr Make(Expr a, Expr b);
     void Verify() const override;
     static const IrNodeTy _node_type_ = IrNodeTy::GT;
   };
   
   struct GE : public BinaryOpNode<GE> {
     GE(Expr a, Expr b) : BinaryOpNode<GE>(a.type(), a, b) {}
   
     Type type() const { return Bool(a()->type().lanes()); }
   
     static Expr Make(Expr a, Expr b);
     void Verify() const override;
     static const IrNodeTy _node_type_ = IrNodeTy::GE;
   };
   
   struct And : public BinaryOpNode<And> {
     And(Expr a, Expr b) : BinaryOpNode<And>(a.type(), a, b) {
       CHECK(a->type().is_bool());
       CHECK(b->type().is_bool());
     }
   
     Type type() const { return Bool(a()->type().lanes()); }
   
     static Expr Make(Expr a, Expr b);
     void Verify() const override;
     static const IrNodeTy _node_type_ = IrNodeTy::And;
   };
   
   struct Minus : public UnaryOpNode<Minus> {
     explicit Minus(Expr x) : UnaryOpNode<Minus>(x.type(), x) {}
   
     static Expr Make(Expr a);
     void Verify() const override;
     static const IrNodeTy _node_type_ = IrNodeTy::Minus;
   };
   
   struct Or : public BinaryOpNode<Or> {
     Or(Expr a, Expr b) : BinaryOpNode<Or>(Bool(), a, b) {
       CHECK(a->type().is_bool());
       CHECK(b->type().is_bool());
     }
   
     static Expr Make(Expr a, Expr b);
   
     Type type() const override;
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Or;
   };
   
   struct Not : public UnaryOpNode<Not> {
     explicit Not(Expr v) : UnaryOpNode<Not>(Bool(), v) {}
   
     static Expr Make(Expr v);
   
     Type type() const override;
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Not;
   };
   
   struct Let : public ExprNode<Let> {
     Expr symbol;
     Expr body;
   
     static Expr Make(Expr symbol, Expr body);
   
     Type type() const override;
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Let;
   
     std::vector<Expr*> expr_fields() override {
       if (!body.defined()) return {&symbol};
       return {&symbol, &body};
     }
     std::vector<const Expr*> expr_fields() const override {
       if (!body.defined()) return {&symbol};
       return {&symbol, &body};
     }
   };
   
   enum CallType : int {
     Extern = 0,
     CINN,
     Intrinsic,
     ISL,
   };
   struct Call : public ExprNode<Call> {
     explicit Call(Type t) : ExprNode<Call>(t) {}
   
     std::string name;
     std::vector<Expr> read_args;
     std::vector<Expr> write_args;
   
     CallType call_type;
     FunctionRef func;
     int value_index{-1};
   
     static Expr Make(Type type,
                      const std::string& name,
                      const std::vector<Expr>& read_args,
                      const std::vector<Expr>& write_args,
                      CallType call_type,
                      FunctionRef func = FunctionRef(),
                      int value_index  = 0);
   
     void Verify() const override;
   
     inline size_t total_args_count() const { return read_args.size() + write_args.size(); }
   
     inline bool is_extern_call() const { return call_type == CallType::Extern; }
     inline bool is_cinn_call() const { return call_type == CallType::CINN; }
     inline bool is_intrinsic_call() const { return call_type == CallType::Intrinsic; }
     inline bool is_isl_call() const { return call_type == CallType::ISL; }
   
     std::vector<Expr*> expr_fields() override;
     std::vector<const Expr*> expr_fields() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Call;
   };
   
   struct _Var_ : public ExprNode<_Var_> {
     std::string name;
   
     bool is_reduce_axis{false};
     // @{
     Expr lower_bound;
     Expr upper_bound;
     // @}
   
     // ! Extra tag of this variable/axis.
     std::string tag;
   
     _Var_() = default;
     _Var_(const std::string& name, Type type) : ExprNode<_Var_>(type), name(name) {}
   
     static Expr Make(const std::string& name, const Type& type);
     static Expr Make(Expr lower_bound, Expr upper_bound, const std::string& name);
   
     void Verify() const override;
   
     Expr Copy() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::_Var_;
   };
   
   struct Var : public IrNodeRef {
     Var() = default;
     explicit Var(IrNode* n) : IrNodeRef(n) {}
     explicit Var(const std::string& name_hint, Type t = type_of<int>()) : Var(_Var_::Make(name_hint, t).ptr()) {}
     Var(Expr lower_bound, Expr upper_bound, const std::string& name) : Var(_Var_::Make(lower_bound, upper_bound, name)) {}
     Var(int upper_bound, const std::string& name) : Var(_Var_::Make(Expr(0), Expr(upper_bound), name)) {}
     Var(Expr upper_bound, const std::string& name) : Var(_Var_::Make(Expr(0), upper_bound, name)) {}
   
     operator Expr() { return Expr(get()); }
     operator Expr() const {
       Var v = *this;
       return Expr(v);
     }
   
     bool operator==(const Var& o) const;
     bool operator!=(const Var& o) const;
   
     Var& operator=(_Var_* x);
     Var& operator=(const _Var_* x);
   
     const _Var_* operator->() const { return get(); }
     _Var_* operator->() { return get(); }
     const _Var_* get() const { return static_cast<const _Var_*>(ptr()); }
     _Var_* get() { return static_cast<_Var_*>(ptr()); }
   };
   
   struct Reduce : public ExprNode<Reduce> {
     enum ReduceType {
       kSum = 0,
       kSub,
       kMul,
       kDiv,
       kMax,
       kMin,
     };
   
     Expr init;
   
     // ! The body.
     Expr body;
   
     utils::SmallVector<Var, 4> reduce_axis;
   
     ReduceType reduce_type;
   
     static Expr Make(ReduceType reduce_type, Expr init, Expr body, const std::vector<Var>& reduce_aixs);
   
     Type type() const override { return body.type().ElementOf(); }
   
     std::vector<Expr*> expr_fields() override;
     std::vector<const Expr*> expr_fields() const override;
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Reduce;
   };
   
   struct Select : public ExprNode<Select> {
     Expr condition;
     Expr true_value;
     Expr false_value;
   
     Select(Expr condition, Expr true_value, Expr false_value)
         : ExprNode<Select>(true_value.type()), condition(condition), true_value(true_value), false_value(false_value) {
       CHECK_EQ(true_value.type(), false_value.type());
       CHECK(condition.type().is_bool());
     }
   
     static Expr Make(Expr condition, Expr true_value, Expr false_value) {
       auto node = make_shared<Select>(condition, true_value, false_value);
       return Expr(node);
     }
   
     Type type() const override {
       CHECK_EQ(true_value.type(), false_value.type());
       return true_value.type();
     }
   
     void Verify() const override;
   
     std::vector<Expr*> expr_fields() override { return {&condition, &true_value, &false_value}; }
     std::vector<const Expr*> expr_fields() const override { return {&condition, &true_value, &false_value}; }
   
     static const IrNodeTy _node_type_ = IrNodeTy::Select;
   };
   
   struct LoadStoreAddrMnger {
     Expr tensor;  // Should be a tensor or a scalar.
     bool is_addr_tensor() const;
     bool is_addr_scalar() const;
   };
   
   struct Load : public ExprNode<Load>, public LoadStoreAddrMnger {
     std::vector<Expr> indices;
     Expr index() const;
   
     static Expr Make(Expr tensor, const std::vector<Expr>& indices);
   
     std::vector<Expr*> expr_fields() override;
     std::vector<const Expr*> expr_fields() const override;
   
     void Verify() const override;
   
     const std::string& name() const;
   
     Type type() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Load;
   };
   
   struct Store : public ExprNode<Store>, public LoadStoreAddrMnger {
     Expr value;
     std::vector<Expr> indices;
   
     static Expr Make(Expr tensor, Expr value, const std::vector<Expr>& indices);
   
     std::vector<Expr*> expr_fields() override;
     std::vector<const Expr*> expr_fields() const override;
   
     void Verify() const override;
   
     Type type() const override;
     Expr index() const;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Store;
   };
   
   struct Alloc : public ExprNode<Alloc> {
     Expr destination;
     std::vector<Expr> extents;
     // NOTE the condition might be undefined, that means always true.
     Expr condition;
     // NOTE the body might be undefined, that means no specific logic other than default.
     Expr body;
   
     Alloc() : ExprNode(Type()) {}
   
     static Expr Make(Expr dest, Type type, const std::vector<Expr>& extents, Expr condition, Expr body);
   
     std::vector<Expr*> expr_fields() override;
     std::vector<const Expr*> expr_fields() const override;
   
     void Verify() const override;
   
     int32_t ConstantAllocationSize() const;
     static int32_t ConstantAllocationSize(const std::vector<Expr>& extents);
   
     static const IrNodeTy _node_type_ = IrNodeTy::Alloc;
   };
   
   struct Free : public ExprNode<Free> {
     Expr destination;
   
     Free() : ExprNode(Type()) {}
   
     static Expr Make(Expr dest);
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Free;
   };
   
   struct IfThenElse : public ExprNode<IfThenElse> {
     Expr condition;
     Expr true_case;
     Expr false_case;
   
     IfThenElse(Expr condition, Expr true_case, Expr false_case);
   
     static Expr Make(Expr condition, Expr true_case, Expr false_case = Expr());
   
     void Verify() const override {
       CHECK(condition.defined());
       CHECK(true_case.defined());
       CHECK_EQ(condition.type(), type_of<bool>());
     }
   
     std::vector<Expr*> expr_fields() override;
     std::vector<const Expr*> expr_fields() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::IfThenElse;
   };
   
   enum class ForType : int {
     Serial     = 0,       
     Parallel   = 1,       
     Vectorized = 1 << 1,  
     Unrolled   = 1 << 2,  
     GPUThread  = 1 << 3,  
     GPUBlock   = 1 << 4,  
     GPULane    = 1 << 5,  
   };
   
   struct VectorizeInfo {
     VectorizeInfo() = default;
     VectorizeInfo(int level, int factor) : level(level), factor(factor) {}
   
     int level{-1};
     int factor{-1};
   
     inline void set(int level, int factor) {
       this->level  = level;
       this->factor = factor;
     }
     inline bool valid() const { return level >= 0 && factor > 0; }
   };
   
   struct ForBase {
     ForType for_type() const { return for_type_; }
     void set_for_type(ForType x) { for_type_ = x; }
   
     void set_vectorize_info(const VectorizeInfo& x) {
       if (x.valid()) set_vectorized();
       vectorize_info_ = x;
     }
     const VectorizeInfo& vectorize_info() const { return vectorize_info_; }
   
     void reset_vectorize_info() {
       set_vectorized(false);
       vectorize_info_.factor = -1;
       vectorize_info_.level  = -1;
     }
   
     void set_serial() { for_type_ = ForType::Serial; }
   
     void set_unrolled(bool x = true) {
       if (x)
         set_for_type_flag(ForType::Unrolled);
       else
         unset_for_type_flag(ForType::Unrolled);
     }
     void set_vectorized(bool x = true) {
       if (x)
         set_for_type_flag(ForType::Vectorized);
       else
         unset_for_type_flag(ForType::Vectorized);
     }
     void set_parallel(bool x = true) {
       if (x)
         set_for_type_flag(ForType::Parallel);
       else
         unset_for_type_flag(ForType::Parallel);
     }
   
     inline bool is_serial() const { return for_type_ == ForType::Serial; }
     inline bool is_unrolled() const { return tell_for_type_flag(ForType::Unrolled); }
     inline bool is_vectorized() const { return tell_for_type_flag(ForType::Vectorized); }
     inline bool is_parallel() const { return tell_for_type_flag(ForType::Parallel); }
   
    private:
     inline void set_for_type_flag(ForType type) { *reinterpret_cast<int*>(&for_type_) |= static_cast<int>(type); }
     inline void unset_for_type_flag(ForType type) { *reinterpret_cast<int*>(&for_type_) &= ~static_cast<int>(type); }
     inline bool tell_for_type_flag(ForType type) const { return static_cast<int>(for_type_) & static_cast<int>(type); }
   
     ForType for_type_{ForType::Serial};
     VectorizeInfo vectorize_info_;
   };
   
   struct LLVMForLoopMeta {
     enum UnrollMode { DefaultUnroll, FullyUnroll, NoUnroll };
   
     UnrollMode unroll_mode{DefaultUnroll};
     bool vectorization{true};
   };
   
   struct For : public ExprNode<For>, public ForBase {
     Var loop_var;
     Expr min;
     Expr extent;
   
     Expr body;
   
     DeviceAPI device_api;
   
     LLVMForLoopMeta metadata;
   
     static Expr Make(Var loop_var,
                      Expr min,
                      Expr extent,
                      ForType for_type,
                      DeviceAPI device_api,
                      Expr body,
                      VectorizeInfo vector_info = VectorizeInfo());
   
     void Verify() const override;
   
     std::vector<Expr*> expr_fields() override;
     std::vector<const Expr*> expr_fields() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::For;
   };
   
   struct PolyFor : public ExprNode<PolyFor>, public ForBase {
     Var iterator;
     // Initial value of the iterator.
     Expr init;
     Expr condition;
     Expr inc;
     Expr body;
   
     DeviceAPI device_api;
   
     PolyFor() : ExprNode(Type()) {}
   
     Expr extent() const;
   
     static Expr Make(Var iterator,
                      Expr init_val,
                      Expr condition,
                      Expr inc,
                      ForType for_type,
                      DeviceAPI device_api,
                      Expr body,
                      VectorizeInfo vector_info = VectorizeInfo());
   
     void Verify() const override;
   
     std::vector<Expr*> expr_fields() override;
     std::vector<const Expr*> expr_fields() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::PolyFor;
   };
   
   struct Ramp : public ExprNode<Ramp> {
     Expr base, stride;
     int lanes;
   
     static Expr Make(Expr base, Expr stride, int lanes);
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Ramp;
   };
   
   struct Broadcast : public ExprNode<Broadcast> {
     Expr value;
     int lanes;
   
     static Expr Make(Expr value, int lanes);
   
     Type type() const override;
   
     void Verify() const override;
   
     std::vector<Expr*> expr_fields() override { return {&value}; }
     std::vector<const Expr*> expr_fields() const override { return {&value}; }
   
     static const IrNodeTy _node_type_ = IrNodeTy::Broadcast;
   };
   
   struct FracOp : public BinaryOpNode<FracOp> {
     FracOp() { operands().resize(2); }
   
     static Expr Make(Expr n, Expr d);
   
     bool is_constant() const { return a().is_constant() && b().is_constant(); }
   
     double get_constant() const {
       CHECK(is_constant());
       CHECK_NE(b().get_constant(), 0.f);
       return a().get_constant() / b().get_constant();
     }
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::FracOp;
   
     using ExprNode<FracOp>::operands;
   };
   
   struct Power : public ExprNode<Power> {
     Power() { operands().resize(2); }
     static Expr Make(Expr n, Expr d);
   
     void Verify() const override;
   
     Type type() const override {
       CHECK(a().defined());
       return a()->type();
     }
   
     Expr& a() { return operands()[0]; }
     Expr& b() { return operands()[1]; }
     const Expr& a() const { return operands()[0]; }
     const Expr& b() const { return operands()[1]; }
   
     bool is_constant() const { return a().is_constant() && b().is_constant(); }
   
     static const IrNodeTy _node_type_ = IrNodeTy::Power;
   
     using ExprNode<Power>::operands;
   };
   
   struct Product : public ExprNode<Product> {
     static Expr Make(const std::vector<Expr>& vs);
   
     using ExprNode<Product>::operand;
   
     Type type() const override { return operands().front().type(); }
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Product;
   };
   
   struct Sum : public ExprNode<Sum> {
     static Expr Make(const std::vector<Expr>& vs);
   
     using ExprNode<Sum>::operand;
   
     Type type() const override { return operands().front().type(); }
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Sum;
   };
   
   struct Block : public ExprNode<Block> {
     std::vector<Expr> stmts;
   
     Block() : ExprNode(Type()) {}
   
     static Expr Make(const std::vector<Expr>& stmts);
   
     void Verify() const override;
   
     std::vector<Expr*> expr_fields() override;
     std::vector<const Expr*> expr_fields() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::Block;
   };
   
   struct _Module_ : public ExprNode<_Module_> {
     std::string name;
     Target target;
     std::vector<Expr> buffers;
     std::vector<Expr> functions;
     std::vector<Expr> submodules;
   
     static ir::Module Make(const std::string& name, Target target);
   
     void Verify() const override {}
   
     static const IrNodeTy _node_type_ = IrNodeTy::_Module_;
   };
   
   struct PrimitiveNode : public ExprNode<PrimitiveNode> {
     // NOTE attr_t only support POD, can not contain Expr or other IR nodes, or the IRVisitor or IRCopy on PrimitiveNode
     // will result in undefined behavior.
     using attr_t = std::variant<int, float, bool, std::string>;
   
     std::string name;
     std::vector<std::vector<Expr>> arguments;
     std::map<std::string, attr_t> attrs;
   
     static Expr Make(const std::string& name, const std::map<std::string, attr_t>& attrs);
   
     void Verify() const override;
   
     static const IrNodeTy _node_type_ = IrNodeTy::PrimitiveNode;
   };
   
   }  // namespace ir
   
   // Expose the following to cinn namespace for easier usage.
   // @{
   using ir::Expr;
   using ir::Var;
   // @}
   
   }  // namespace cinn
